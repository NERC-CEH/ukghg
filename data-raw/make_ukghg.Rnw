%% system.time(knitr::knit("make_ukghg.Rnw")); tools::texi2pdf("make_ukghg.tex")
%% tools::texi2pdf("make_ukghg.tex")
%% knitr::purl("make_ukghg.Rnw")

\documentclass{article}
\usepackage{amsmath}
\usepackage{outlines}
\usepackage{animate}
\usepackage{authblk}

\begin{document}
\title{Spatio-temporal modelling of anthropogenic and biogenic fluxes of greenhouse gases in the UK\\ \vspace{2 mm} {\large NERC Greenhouse Gas Emissions and Feedbacks Programme}}
\author{Peter Levy, Marcel van Oijen} 
\affil{Centre for Ecology and Hydrology, Edinburgh, UK} 
\date{\today} 
\
title
Code run from: \verb|\Sexpr{getwd()}|

\section{Introduction} 
This document describes the code used to produce spatio-temporal predictions of UK GHG emissions for the period 1990 to 2011.  We have provided an R package which contains the data and code to do this.  Most users will only interact with a single function \texttt{getAflux}, which returns a map, given a date-time stamp as input, optionally returning just the values for a single sector.
Here, we document all the code for producing this package.

\section{Packages required}
Firstly, we load the necessary packages. 
<<start_up, eval=TRUE, results='asis', echo=TRUE, warning=FALSE, message=FALSE>>=
## Fri 22 April 2016
## changed to using 2013 area sources
## units changed to using Tg throughout (all gases, nat totals, point sources, area sources)
## alpha_year_df needs to include all ghgs, 
## to do:
## needs to select GHG appropriately in calcAlpha - subset by extra arg
## if (exists()) construct used to add rows to existing df
##    better to add dfs to list - how?
## check functions unitConversion & calcFlux still work properly
## should change to use 2013 pt source data, from Excel?
## could add all pt source data and select by year and sector, but only 3? years available
## reproject - quick version and re-rasterised version
## separate make_ukghg and ukghg projects

# R script to extrapolate the UK anthropogenic GHG emission maps
# across the years 1990 to 2011
# using the R raster package.
# See http://cran.r-project.org/web/packages/raster/index.html
# Data from NAEI and DECC web sites ***
#
## Peter Levy, CEH Edinburgh
## Bush Estate, Penicuik, EH26 0QB, U.K.
## plevy@ceh.ac.uk
## Tel: 0131 445 8556

rm(list=ls(all=TRUE))
#install.packages("xlsx")
#install.packages("ggplot2", "mgcv")
library(devtools)
library(roxygen2)
library(knitr)
library(raster)
library(rgdal)
library(ncdf4)
library(animation)
library(mgcv)
library(ggplot2)
library(readxl)
library(plyr)

# set constants
# reference year for spatial data and alpha_year = 1
refYear <- 2013
# all ghgs need same startYear 
startYear <- 1990 # first year of data in annual time series in .xlsx file
endYear   <- 2020 # last year of data in annual time series in .xlsx file
# get index for reference year
irefYear <- refYear - startYear+1
# projection string for OSGB 1936 / British National Grid 
# note that fewer signif places seem to be used when projecting stacks cf rasters
# k=0.999601272 was originally k=0.9996012717 but compareRasters was then FALSE when doing raster arithmetic
projOSGB <- "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.999601272 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs"
projLonLat <- "+proj=longlat +datum=WGS84"
proj <- "OSGB" # or "LonLat"
ghgName <- c("ch4", "co2", "n2o")  # "ch4"
#ghgName <- "ch4"
unitType <- "mol" # "g"
unitSIprefix <- "nano"
#IMconvertPath <- "/Progra~1/ImageMagick-6.8.9-Q16/convert.exe" # on ToughBook
#IMconvertPath <- "/Progra~1/ImageMagick-6.9.0-Q16/convert.exe" # on Desktop

@

<<read_nat_annual_data, eval=FALSE>>=
# Read in national GHG emission data from:
# https://www.gov.uk/government/collections/final-uk-greenhouse-gas-emissions-national-statistics
# and future projections from:
# https://www.gov.uk/government/publications/updated-energy-and-emissions-projections-2015
#fname <- "./20160331_2014_Final_Emissions_data_tables.xlsx"
fname <- "./20170301_2015_Final_Emissions_data_tables.xlsx"
wb <- loadWorkbook(fname)  
sheets <- getSheets(wb)
nCharCols <- 3 # We want columns 1-3 as factors, the rest numeric
startCol <- 1
startRow <- 5

#rm(ghg_byYear_bySector_df)

for (ighg in 1:3){
  #ighg <- 1
  if (ghgName[ighg] == "ch4"){
    sheet <- sheets[["Table 5"]]
    nDataCols <- endYear - startYear + 1
    endRow <- 79  
    GWP <- 25  # value used by DECC
  } else if (ghgName[ighg] == "co2"){
    sheet <- sheets[["Table 4"]]
    nDataCols <- endYear - 1970 + 1
    endRow <- 87 
    GWP <- 1
  } else if (ghgName[ighg] == "n2o"){
    sheet <- sheets[["Table 6"]]
    nDataCols <- endYear - startYear + 1
    endRow  <- 80
    GWP <- 298  # value used by DECC
  }

  endCol <- startCol + nCharCols + nDataCols -1
  df <- readColumns(sheet, startColumn=startCol, endColumn=endCol, 
                               startRow=startRow,     endRow=endRow, 
        colClasses = c(rep("character", nCharCols), rep("numeric", nDataCols)))
       
  #str(df)
  #df$SNAPsector 
  df <- df[-1:-3, ] # remove blank rows at top and "(a) By source"
  iRow <- (df$SNAPsector != "") # select the rows with SNAPsector values
  df <- df[iRow, ]              # and use only these
  # to get totals by SNAPsector
  df <- ddply(df, .(SNAPsector), numcolwise(sum, na.rm = TRUE))
  sum(df$X1990); sum(df$X2011)  # check totals correct

  # Transpose df
  dft <- as.data.frame(t(df[,2:ncol(df)]))
  # Set the column headings
  colnames(dft) <- as.character(df[,1])

  # convert Tg (=Mt) CO2e to Tg mass
  df <- dft / GWP

  df$solvents <- df$lulucf
  df$solvents <- 0
  df$lulucf <- NULL

  sectorName <- c("energyprod", "domcom", "indcom", "indproc", "offshore", 
               "solvents", "roadtrans", "othertrans", "waste", "agric")
  sectorLongName <- c("Energy production", "Domestic combustion", "Industrial combustion", "Industrial process", "Offshore", 
               "Solvents", "Road Transport", "Other Transport", "Waste", "Agriculture") 
  nSectors <- length(sectorName)
  # re-order in sectorName order
  df <- df[, sectorName]
  # extract year from row names
  year <- as.numeric(substr(rownames(df),2,5))
  df <- data.frame(ghgName[ighg], year, df)

  if (exists("ghg_byYear_bySector_df")){
    ghg_byYear_bySector_df <- rbind(ghg_byYear_bySector_df, df)
  } else {
    ghg_byYear_bySector_df <- df
  }
}

attr(ghg_byYear_bySector_df, "units") <- "Tg ghg y-1"
# make sure all have same start year (end year?)
ghg_byYear_bySector_df <- subset(ghg_byYear_bySector_df, year >= startYear)
@

\section{Data required}
The processing is done for either CO2, CH4 or N2O, depending on the setting \texttt{ghgName}.
Units need to be kept consistent for the area sources, point sources, and national totals, so that the spatial data can be normalised correctly using the national total.  Thereafter, the spatial data can be output in any desired units; defaults are $\mu$mol m$^{-2}$ s$^{-1}$ for CO2, and nmol m$^{-2}$ s$^{-1}$ for CH4 and N2O

\section{Calculate alpha year}
Calculate $\alpha_year$
<<calc_alpha_year, eval=FALSE, results='asis', echo=TRUE, warning=FALSE, message=FALSE>>=
#rm(alpha_year_byGHG_df)

for (ighg in 1:3){
  #ighg <- 1
  df  <- subset(ghg_byYear_bySector_df, ghgName.ighg. == ghgName[ighg])
  # needs to useghg_byYear_bySector_df
  alpha_year_df <- with(df, data.frame(ghgName.ighg., year))
  alpha_year_df[,3:(nSectors+2)] <- sweep(df[,3:(nSectors+2)], 2, 
                       as.numeric(df[irefYear,3:(nSectors+2)]), `/`)
  # change any NaNs to zeros
  alpha_year_df[is.na(alpha_year_df)] <- 0
  names(alpha_year_df)

  alpha_year_df <- reshape(alpha_year_df, varying = list(3:(nSectors+2)), 
    v.names = "alpha_year", direction = "long", timevar = "sector")
  alpha_year_df$sector <- factor(alpha_year_df$sector)
  alpha_year_df$sectorName <- sectorName[alpha_year_df$sector]

  if (exists("alpha_year_byGHG_df")){
    alpha_year_byGHG_df <- rbind(alpha_year_byGHG_df, alpha_year_df)
  } else {
    alpha_year_byGHG_df <- alpha_year_df
  }
}

p <- ggplot(alpha_year_byGHG_df, aes(x = year, y = alpha_year, colour = ghgName.ighg.))
p <- p + geom_line()
p <- p + ylab(expression(alpha[i*","*year]))
p <- p + ggtitle(expression(paste("Annual variation in emissions from 4 sectors, ", italic(alpha)[i*","*year])))
p + facet_wrap(~ sectorName, scale = "free")
@

\section{Calculate alpha yday}
Calculate $\alpha_yday$
<<calc_alpha_yday, eval=FALSE, results='asis', echo=TRUE, warning=TRUE, message=TRUE>>=
# read in the coefficients for disaggregating seasonal variation
alpha_yday_df <- read.csv("ukGHG_emission_bySNAP_byMonth.csv")
alpha_yday_df$yday <- seq(15, by = 30, length = 12)
names(alpha_yday_df)

T <- c(5.5, 5.6, 7.6, 9.5, 12.9, 15.8, 18.2, 18.1, 15.5, 12, 8.3, 6.5)
T_prime <- T - mean(T)
k <- 0.0674 # Q10 = 2
alpha_yday_df$waste <- 1 * exp(k * T_prime)

alpha_yday_df <- reshape(alpha_yday_df, varying = list(2:11), #2:11 
  v.names = "alpha", direction = "long", timevar = "sector")
alpha_yday_df$sector <- factor(alpha_yday_df$sector)
alpha_yday_df$sectorName <- sectorName[alpha_yday_df$sector]

mod.yday <- gam(alpha ~ s(yday, by = sector, bs = "cc"), 
              data = alpha_yday_df)       
# examine model fit              
summary(mod.yday)
#plot(mod.yday, pages =1)

# fitted model predictions
alpha_yday_df$alpha_pred <- predict.gam(mod.yday, alpha_yday_df, newdata.guaranteed=TRUE)
#p <- ggplot(subset(alpha_yday_df, as.numeric(sector) <= 4), aes(x = yday, y = alpha_pred, colour = sectorName))
p <- ggplot(alpha_yday_df, aes(x = yday, y = alpha_pred, colour = sectorName))
p <- p + geom_line()
p <- p + geom_point(aes(y = alpha))
p <- p + ylab(expression(alpha[i*","*yday]))
p <- p + ggtitle(expression(paste("Seasonal variation in emissions, ", italic(alpha)[i*","*yday])))
p + facet_wrap(~ sectorName, scale = "fixed") + guides(colour=FALSE)
@

\section{Calculate alpha wday}
Calculate $\alpha_wday$
<<calc_alpha_wday, eval=FALSE, results='asis', echo=TRUE>>=
# repeat for weekly variation
# read in the coefficients for disaggregating seasonal and diurnal variation
alpha_wday_df <- read.csv("ukGHG_emission_bySNAP_byDayOfWeek.csv")
alpha_wday_df$wday <- as.numeric(rownames(alpha_wday_df))
names(alpha_wday_df)

alpha_wday_df <- reshape(alpha_wday_df, varying = list(2:11), 
  v.names = "alpha_wday", direction = "long", timevar = "sector")
alpha_wday_df$sector <- factor(alpha_wday_df$sector)
alpha_wday_df$sectorName <- sectorName[alpha_wday_df$sector]

# fitted model predictions
# don't need a gam as no interpolation needed.
p <- ggplot(alpha_wday_df, aes(x = wday, y = alpha_wday, colour = sectorName))
p <- p + geom_line()
p <- p + ylab(expression(italic(alpha)[i*","*wday]))
p <- p + ggtitle(expression(paste("Intra-week variation in emissions, ", italic(alpha)[i*","*hour])))
p + facet_wrap(~ sectorName, scale = "fixed") + guides(colour=FALSE)
@

\section{Calculate alpha hour}
Calculate $\alpha_hour$
<<calc_alpha_hour, eval=FALSE, results='asis', echo=TRUE>>=
# repeat for diurnal variation
# read in the coefficients for disaggregating seasonal and diurnal variation
alpha_hour_df <- read.csv("ukGHG_emission_bySNAP_byHour.csv")
alpha_hour_df$hour <- as.numeric(rownames(alpha_hour_df))
names(alpha_hour_df)

alpha_hour_df <- reshape(alpha_hour_df, varying = list(2:11), 
  v.names = "alpha", direction = "long", timevar = "sector")
alpha_hour_df$sector <- factor(alpha_hour_df$sector)
alpha_hour_df$sectorName <- sectorName[alpha_hour_df$sector]

mod.hour <- gam(alpha ~ s(hour, by = sector, bs = "cc"),
              data = alpha_hour_df)       
# examine model fit              
#summary(mod.hour)
#plot(mod.hour, pages =1)

# fitted model predictions
alpha_hour_df$alpha_pred <- predict.gam(mod.hour, alpha_hour_df, newdata.guaranteed=TRUE)
p <- ggplot(subset(alpha_hour_df, as.numeric(sector) <= 10), aes(x = hour, y = alpha_pred, colour = sectorName))
p <- p + geom_line()
p <- p + ylab(expression(italic(alpha)[i*","*hour]))
p <- p + ggtitle(expression(paste("Diurnal variation in emissions from 4 sectors, ", italic(alpha)[i*","*hour])))
p + facet_wrap(~ sectorName, scale = "fixed") + guides(colour=FALSE)
@

\section{Read beta data}
Calculate $\beta$
<<calc_beta, eval=FALSE, results='asis', echo=TRUE>>=
# read in the coefficients for modifyinh alpha variation
beta_df <- read.csv("beta_df.csv")
@


\section{Spatial pattern}
Spatial pattern
<<spatial_data, eval=FALSE>>=

for (ighg in 1:3){
  #ighg <- 1  
  # select the national annual emissions for current ghg
  df  <- subset(ghg_byYear_bySector_df, ghgName.ighg. == ghgName[ighg])

  # read in point sources of GHG emissions
  if (ghgName[ighg] == "ch4") {
    # read in point source data, which is additional to area sources in sector maps
    ptdf <- read.csv("ch4/uk_ch4_2006_pointSources_Mg_y-1.csv")
    # factor to convert Mg to Tg
    spatial_to_national_unitConv <- 1/1e6
  } else if (ghgName[ighg] == "co2") {
    # read in point source data, which is additional to area sources in sector maps
    ptdf <- read.csv("co2/uk_co2_2008_pointSources_MgC_y-1.csv")
    # factor to convert Mg CO2-C to Tg CO2
    spatial_to_national_unitConv <- 1/12*44 /1e6
  } else if (ghgName[ighg] == "n2o"){
    # read in point source data, which is additional to area sources in sector maps
    ptdf <- read.csv("n2o/uk_n2o_2006_pointSources_Mg_y-1.csv")
    # factor to convert Mg to Tg
    spatial_to_national_unitConv <- 1/1e6
  }

  # convert Mg CO2-C y-1 to  Gg CH4 y-1, Tg CO2 y-1, or Gg N2O y-1
  ptdf$SumOfEmission <- ptdf$SumOfEmission * spatial_to_national_unitConv
  # there are 90 point sources with missing E & N, most/all offshore - miss these out for now
  # put them in London or Aberdeen? Depending on ghg?
  ptdf <- na.omit(ptdf)

  # read in area sources of GHG emissions
  rfile  <- paste(refYear, "/", ghgName[ighg], "/", sectorName, ghgName[ighg], substr(refYear, 3, 4), ".asc", sep = "")
  # make a stack for nYears
  r <- raster(rfile[1]) #, values = FALSE)
  e <- extent(r) # get the extent for later use
  r <- setValues(r, 0) # set to zero, not NA
  # set projection to be OSGB 1936 / British National Grid 
  projection(r) <- projOSGB
  # make a stack for each sector for the reference year
  ghgBySector <- stack(rep(list(r), nSectors))

  for (iSector in 1:(nSectors)){
    # iSector <- 5
    if (iSector == 6) next  # no spatial data file for solvents, only keeping so that order no. matches SMAP no.
    # read in map for each sector; units are Mg ch4 km-2 y-1
    r <- raster(rfile[iSector])
    # convert spatial data to same as national data units
    r <- r * spatial_to_national_unitConv
    r <- extend(r, e) # agric sector has small extent
    r <- crop(r, e) # waste sector has larger extent
    r[is.na(r)] <- 0 # can't sum with missing values

    ## subset point sources by sector
    pointSourceBySector <- ptdf[ptdf$SnapID == iSector, ]
    # if no values for this sector, no point sources to rasterise
    if (sum(pointSourceBySector$SumOfEmission) == 0){
      rp <- 0
    } else {
      # make a raster with the sum of point sources in each grid cell
      xy <- cbind(pointSourceBySector$Easting, pointSourceBySector$Northing)
      rp <- rasterize(xy, r, pointSourceBySector$SumOfEmission, fun=sum)
      rp[is.na(rp)] <- 0 # can't sum with missing values  
    }

    ghgBySector[[iSector]] <- r + rp

    sum_pts <- sum(pointSourceBySector$SumOfEmission)
    sum_area  <- cellStats(r, "sum")
    #sc <- cellStats(rp, "sum")
    sum_spatial_total <- cellStats(ghgBySector[[iSector]], "sum")
    national_stats_total <- df[irefYear,2+iSector]
    cat(iSector, rfile[iSector], sum_area, sum_pts, sum_spatial_total, national_stats_total, colnames(df[iSector+1]), "\n")

    # correct so that spatial total is forced to national stats total
    relEmis_national <- national_stats_total / sum_spatial_total
    ghgBySector[[iSector]] <- ghgBySector[[iSector]] * relEmis_national
    cat(iSector, rfile[iSector], relEmis_national, cellStats(ghgBySector[[iSector]], "sum"), national_stats_total, colnames(df[iSector+1]), "\n")
  } # iSector
  # check totals for reference year match
  print(sum(cellStats(ghgBySector, "sum"))); print(sum(df[irefYear,3:(2+nSectors)]))

  # assign attributes and write to native raster file
  names(ghgBySector) <- sectorName
  attr(ghgBySector, "units") <- "Tg km-2 y-1"
  rf <- writeRaster(ghgBySector, filename=paste(ghgName[ighg], "BySector.grd", sep=""), overwrite=TRUE)
} # ighg
@

\section{Save / load data}
<<save_data, eval=FALSE>>=
# don't think this works - data saved in tmp dir?
#save(ch4BySector, co2BySector, n2oBySector, file="ghgBySector.RData")
#save(nSectors, sectorName, alpha_year_byGHG_df, mod.yday, alpha_wday_df, mod.hour, file = "ukghg.RData")
# or all in a oner
#save(ch4BySector, co2BySector, n2oBySector, nSectors, sectorName, alpha_year_df, mod.yday, alpha_wday_df, mod.hour, file = "ukghg_withStacks.RData")
@

<<load_data, eval=TRUE>>=
load(file = "ukghg.RData", verbose = TRUE)
ch4BySector <- stack("ch4BySector.grd")
co2BySector <- stack("co2BySector.grd")
n2oBySector <- stack("n2oBySector.grd")
ch4_mean_Tgkm2y <- raster("Fch4_mean_Tgkm2y.grd")
lai <- raster("lai.grd")  

# or all in a oner
# don't think this works - data saved in tmp dir?
#load(file = "ukghg_withStacks.RData", verbose = TRUE)
#load(file = "ghgBySector.RData", verbose = TRUE)

###################
## Made invModel output conform with ukghg model output
##  beta_df now added as argument to calcFlux, so can be sampled
## query now is how to load low res stack along with the hi res data
## can we pass a data frame or matrix to likelihood function in BT?
## book London travel
###################
@

<<reproject>>=
projection(ch4BySector)
res(ch4BySector)
projLonLat
# ch4
# project the brick into lon-lat co-ords
system.time(ch4BySector_LonLat <- projectRaster(ch4BySector, crs = projLonLat,  method="ngb"))
rf <- writeRaster(ch4BySector_LonLat, filename="ch4BySector_LonLat.grd")
# co2
system.time(co2BySector_LonLat <- projectRaster(co2BySector, crs = projLonLat,  method="ngb"))
rf <- writeRaster(co2BySector_LonLat, filename="co2BySector_LonLat.grd")
# n2o
system.time(n2oBySector_LonLat <- projectRaster(n2oBySector, crs = projLonLat,  method="ngb"))
rf <- writeRaster(n2oBySector_LonLat, filename="n2oBySector_LonLat.grd")
# Fch4_mean_Tgkm2y
system.time(ch4_mean_Tgkm2y_LonLat <- projectRaster(ch4_mean_Tgkm2y, crs = projLonLat,  method="ngb"))
rf <- writeRaster(ch4_mean_Tgkm2y_LonLat, filename="ch4_mean_Tgkm2y_LonLat.grd")
# lai
system.time(lai_LonLat <- projectRaster(lai, crs = projLonLat,  method="ngb"))
rf <- writeRaster(lai_LonLat, filename="lai_LonLat.grd")

projection(ch4BySector_LonLat)
plot(ch4BySector_LonLat)
@

\section{Make aggregated GHG flux stack}
<<aggregate_data, eval=FALSE, results='asis', echo=TRUE, warning=TRUE, message=TRUE>>=
path = "ukghg/inst/extdata/"
ghgName <- "n2o"
proj <- "OSGB"
res1 <- 1 # km
res <- 100 # km
fname     <- paste(path, ghgName, "BySector_", proj, ".grd", sep="")
fname <- paste(path, ghgName, "BySector_", proj, "_", res1, "km.grd", sep="")
fname_agg <- paste(path, ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
ghgBySector <- stack(fname_agg)
cellStats(ghgBySector[[1]], sum) * res^2
s_agg <- aggregate(ghgBySector, fac = res)
rf <- writeRaster(s_agg, filename=fname_agg)

# lai
fname     <- paste(path, "lai_", proj, ".grd", sep="")
fname_agg <- paste(path, "lai_", proj, "_", res, "km.grd", sep="")
s <- raster(fname)
s_agg <- aggregate(s, fac = res)
rf <- writeRaster(s_agg, filename=fname_agg)

# Fch4 biogenic
fname <- paste(path, ghgName, "BySector_", proj, "_", res1, "km.grd", sep="")
fname_agg <- paste(path, "Fch4_mean_Tgkm2y_", proj, "_", res, "km.grd", sep="")
s     <- raster(fname)
s_agg <- raster(fname_agg)
cellStats(s, sum) * res1^2
cellStats(s_agg, sum) * res^2
s_agg <- aggregate(s, fac = res)
rf <- writeRaster(s_agg, filename=fname_agg)

@

\section{Make ukghg package}
<<make_package, eval=TRUE, results='asis', echo=TRUE, warning=TRUE, message=TRUE>>=
rm(list=ls(all=TRUE))
#install.packages("knitr")
library(devtools)  # alternative is devtools::install_github("klutometis/roxygen")
library(roxygen2)
library(knitr)
getwd()

# quick way of testing pkg functions without building package
source("./R/ukghg.R")

#load(file = "ukghg.RData", verbose = TRUE)
#nSectors, sectorName, sectorLongName, alpha_year_byGHG_df, mod.yday, alpha_wday_df, mod.hour

#create("ukghg") # if it doesn't already exist
# Add functions in files to R/ directory 

setwd("./ukghg")
#devtools::use_data(nSectors, sectorName, sectorLongName, alpha_year_byGHG_df, mod.yday, alpha_wday_df, mod.hour, overwrite = TRUE)
#devtools::use_data(ch4BySector, co2BySector, n2oBySector, internal = TRUE)

check_man()
document()
clean_vignettes()
build_vignettes()

# build the manual
#Sys.getenv(c("R_TEXI2DVICMD", "R_PAPERSIZE", "RD2PDF_INPUTENC"))
#Sys.setenv(RD2PDF_INPUTENC = "inputenx ")
pack <- "ukghg"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(path)))
#C:/PROGRA~1/R/R-32~1.4RE/bin/x64/R R CMD Rd2pdf --no-clean N:/0Peter/prop/UKinverseFlux/GHG_TAP/DelD/anthEmis/ukghg

system.time(
  check(manual = FALSE, vignettes = FALSE)
)
build()
build(manual = FALSE, vignettes = FALSE)
build(binary = TRUE)

setwd("..")
install("ukghg")
install.packages("./ukghg_0.1.tar.gz", repos = NULL, type="source")
library(ukghg)
vignette("use_ukghg")
?ukghg
?calcFlux
?calcFlux_anthro
?calcFlux_bio
?combineFlux
?writeNetCDF
?writeGIF
startDate <- as.POSIXct(strptime("01/01/2014 12:00", "%d/%m/%Y %H:%M"), tz = "UTC")
endDate   <- as.POSIXct(strptime("01/12/2014 12:00", "%d/%m/%Y %H:%M"), tz = "UTC")
# create a sequence of dates
nTimes <- 12
datect <- seq(startDate, endDate, length = nTimes)
flux_100 <- calcFlux("co2", datect, proj = "OSGB", 
  res = "100", unitType = "mol", unitSIprefix = "micro", timeScales = c(TRUE, TRUE, FALSE, FALSE))
plot(datect, flux_100$total, col = "red", type = "b")

flux_100 <- calcFlux("ch4", datect, proj = "OSGB", res = "100", "mol", "nano", writeNetCDF = FALSE)
system.time(flux_100 <- calcFlux("ch4", datect, proj = "OSGB", res = "100", "mol", "nano", writeNetCDF = FALSE))
plot(datect, flux_100$total, col = "red", type = "b", ylim = c(0, 7))
flux_1   <- calcFlux("ch4", datect, proj = "OSGB", res = "1",   "mol", "nano", writeNetCDF = FALSE, writeGIF = FALSE)
flux_20  <- calcFlux("ch4", datect, proj = "OSGB", res = "20",  "mol", "nano", writeNetCDF = FALSE, writeGIF = FALSE)
myFlux <- calcFlux("ch4", datect, "OSGB", "mol", "nano", beta_df = beta_df, writeGIF = FALSE)
myFlux <- calcFlux("ch4", datect, "LonLat", "mol", "nano", writeNetCDF = TRUE, writeGIF = TRUE)
ls.str(flux_1)
ls.str(flux_20)
ls.str(flux_100)
str(myFlux, max.level = 1)
points(datect, flux_20$total, col = "blue", type = "b")
points(datect,  flux_1$total, col = "black", type = "b")
waste <- cellStats(flux_100$ls_ghgBySectorByTime[[9]], "sum")
plot(datect, waste)
plot(flux_1$total, flux_20$total)
plot(flux_20$s_ghgTotal)
plot(flux_100$ls_ghgByTimeBySector[[4]], zlim=c(0, 70))
sectorLongName <- c(sectorLongName, "Natural")
names(flux_20$ls_ghgByTimeBySector) <- sectorLongName
plot(flux_20$ls_ghgByTimeBySector[[4]])
names(flux_20$ls_ghgBySectorByTime[[10]]) <- datect
plot(flux_20$ls_ghgBySectorByTime[[10]])
plot(flux_100$ls_ghgByTimeBySector[[4]], zlim=c(0, 70))
# still error checking new functions with empty workspace
# need to add writeNetCDF / PNG functions
# add proj to file names, so either read correctly
# time reprojecting - could be done dynamically to save 100 MB?
@

\section{Calculate alpha}
<<calc_alpha, eval=TRUE, results='asis', echo=TRUE, warning=TRUE, message=TRUE>>=
calcAlpha <- function(ghgName = c("ch4", "co2", "n2o"), 
                      datect, sectorList = 1:10){ # add default
  ghgName <- match.arg(ghgName)
  nTimes <- length(datect)
  iTime <- seq(1, length = nTimes)
  df <- data.frame(iTime, datect)
  # extract useful bits of timestamp
  df$datelt <- as.POSIXlt(df$datect, tz = "UTC")
  df$year <- as.numeric(df$datelt$year)+1900
  df$yday <- as.numeric(df$datelt$yday)
  df$wday <- as.numeric(df$datelt$wday)+1
  df$hour <- as.numeric(df$datelt$hour)
  # subset by ghgName
  alpha_year_df <- subset(alpha_year_byGHG_df, ghgName.ighg. == ghgName)
  df <- merge(df, alpha_year_df, by = c("year"))
  df <- merge(df, alpha_wday_df, by = c("wday", "sector"))

  df$alpha_yday  <- predict.gam(mod.yday, df)
  df$alpha_hour  <- predict.gam(mod.hour, df)
  df <- within(df, alpha <- alpha_year * alpha_yday * alpha_wday * alpha_hour)
  df$sectorName <- df$sectorName.x
  df <- with(df, data.frame(iTime, datect, sector, sectorName, alpha))
  # sort df by sector then date
  df <- df[with(df, order(sector, datect)), ]  
  # subset to just the requested sectors
  df <- subset(df, sector %in% sectorList)
  return(df)
}

startDate <- as.POSIXct(strptime("01/01/2006", "%d/%m/%Y"), tz = "UTC")
endDate   <- as.POSIXct(strptime("01/12/2006", "%d/%m/%Y"), tz = "UTC")
# create a sequence of dates
nTimes <- 12
datect <- seq(startDate, endDate, length = nTimes)
alpha_df <- calcAlpha("ch4", datect)
#alpha_df <- calcAlpha("co2", datect, sectorList = c(2,5,10)) # or select particular sectors
myFlux <- calcFlux("ch4", datect, "OSGB", "mol", "nano")

p <- ggplot(alpha_df, aes(x = datect, y = alpha, colour = sectorName))
p <- p + geom_line()
p <- p + ylab(expression(alpha[i]))
p <- p + ggtitle(expression(paste("Temporal variation in emissions, ", italic(alpha)[i])))
p + facet_wrap(~ sectorName, scale = "fixed") + guides(colour=FALSE)
@

\section{Unit conversions}
Unit conversions
<<unit_conversions, eval=TRUE>>=
# function to convert units from Tg km-2 y-1
unit_conversion <- function(ghgName = c("ch4", "co2", "n2o"), 
                           unitType = c("mol", "g"),
                           unitSIprefix = c("kilo", "none", "milli", "micro", "nano", "pico")){
  ghgName <- match.arg(ghgName)
  unitType <- match.arg(unitType)
  unitSIprefix <- match.arg(unitSIprefix)
  
  secsPerYear <- 365*24*60*60
  km2_to_m2 <- 1e6
  Tg_to_g <- 1e12

  # molecular weight of gases
  if (ghgName == "ch4") {
      molWt <- 16
  } else if (ghgName == "co2") {
      molWt <- 44
  } else if (ghgName == "n2o") {
      molWt <- 44  
  }
  # ugly, but numerically correct
  if (unitType == "g") {
      molWt <- 1
  }

  # unit conversions - this could be outwith the function - stored as data
  #unitSIprefix <- "nano"
  SIprefix <- c("kilo", "none", "milli", "micro", "nano", "pico")
  SI_multiplier <- c(1e-3, 1, 1e3, 1e6, 1e9, 1e12)
  # match prefix with multiplier
  i <- match(unitSIprefix, SIprefix)
  mult <- SI_multiplier[i]
  
  # all gases in Tg
  value <- Tg_to_g *mult /molWt /km2_to_m2 /secsPerYear

  #return(unitConv) 
  # or return name as well
  name <- paste(SIprefix[i], unitType, ghgName, "m^-2_s^-1", sep="_")
  return(list(value=value, # unit conversion multiplier
               name=name))  # unit conversion name  
}

unitConv <- unit_conversion(ghgName, unitType, "nano")
unit_conversion("ch4", "mol", "nano")
unit_conversion("co2", "mol", "micro")
unit_conversion("n2o", "mol", "nano")
unit_conversion("ch4", "g", "nano")
unit_conversion("co2", "g", "micro")
unit_conversion("n2o", "g", "nano")

# convert national total to spatial mean, using UK area of 243610 km2 
TgCH4yUK_to_nmolm2s <- 1e12/16*1e9/(243610*1e6)/(365*24*60*60)
TgCO2yUK_to_umolm2s <- 1e12/44*1e6/(243610*1e6)/(365*24*60*60)
TgN2OyUK_to_nmolm2s <- 1e12/44*1e9/(243610*1e6)/(365*24*60*60)
#df[,2:12] <- df[,2:12] * GgN2OyUK_to_nmolm2s
#df[,2:12] <- df[,2:12] * GgCH4yUK_to_nmolm2s
#df[,2:12] <- df[,2:12] * TgCO2yUK_to_umolm2s
@

\section{Calculate predicted fluxes}
Calculate predicted fluxes

<<calc_flux_predictions, eval=TRUE, results='asis', echo=TRUE, warning=TRUE, message=TRUE>>=
#' A calcFlux Function
#'
#' This function allows you to express your love of cats.
#' @param ghgName Do you love cats? Defaults to TRUE.
#' @param datect Do you love cats? Defaults to TRUE.
#' @param proj Do you love cats? Defaults to TRUE.
#' @param unitType Do you love cats? Defaults to TRUE.
#' @param unitSIprefix Do you love cats? Defaults to TRUE.
#' @param sectorList Do you love cats? Defaults to TRUE.
#' @keywords units
#' @export
#' @examples
#' startDate <- as.POSIXct(strptime("01/06/2006", "%d/%m/%Y"), tz = "UTC")
#' endDate   <- as.POSIXct(strptime("02/06/2006", "%d/%m/%Y"), tz = "UTC")
#' # create a sequence of dates
#' nTimes <- 2
#' datect <- seq(startDate, endDate, length = nTimes)
#' myFlux <- calcFlux("ch4", datect, "OSGB", "mol", "nano")

calcFlux <- function(ghgName = c("ch4", "co2", "n2o"), 
                     datect = datect, 
                     proj = c("OSGB", "LonLat"), 
                     unitType = c("mol", "g"),
                     unitSIprefix = c("kilo", "none", "milli", "micro", "nano", "pico"), 
                     sectorList = 1:10){
  ghgName <- match.arg(ghgName)
  proj <- match.arg(proj)
  unitType <- match.arg(unitType)
  unitSIprefix <- match.arg(unitSIprefix)
  
  # get the data frame of alpha values
  alpha_df <- calcAlpha(ghgName, datect, sectorList)
  # declare an array for the total emission across sectors for each time
  total <- array(dim = nTimes) 
  
  # depending which gas we want, read the appropriate data into stack
  # test version using local *not* package inst\extdata files
  ## comment out for package release version
  if (ghgName == "ch4"){
    ghgBySector <- stack("ch4BySector.grd")
  } else if (ghgName == "co2") {
    ghgBySector <- stack("co2BySector.grd")
  } else if (ghgName == "n2o") {
    ghgBySector <- stack("n2oBySector.grd")
  }

#  # package version using inst\extdata files
  ## uncomment for package release version
#  if (ghgName == "ch4") {
#      ghgfile <- system.file("extdata", "ch4BySector.grd", package="ukghg")
#      #ghgBySector <- ch4BySector
#  } else if (ghgName == "co2") {
#      #ghgBySector <- co2BySector
#      ghgfile <- system.file("extdata", "co2BySector.grd", package="ukghg")
#  } else if (ghgName == "n2o") {
#      #ghgBySector <- n2oBySector
#      ghgfile <- system.file("extdata", "n2oBySector.grd", package="ukghg")
#  }
#  ghgBySector <- stack(ghgfile)
  
  unitConv <- unit_conversion(ghgName, unitType, unitSIprefix)
  
  r <- ghgBySector[[1]]
  # this works with stack, is lost with brick
  r@data@unit <- unitConv$name
  
  # create a stack with nSectors layers
  s_ghgBySector <- brick(r, values=FALSE, nl=nSectors)
  s_ghgBySector  <- setValues(s_ghgBySector, 0)
  # create a stack with nTimes layers
  s_ghgTotal  <- brick(r, values=FALSE, nl=nTimes) 
  s_ghgTotal  <- setValues(s_ghgTotal, 0)
  # create a list of sector stacks, one for each time
  # this structure is used to sum over sectors at each time
  ls_ghgByTimeBySector <- replicate(nTimes, s_ghgBySector)
  # Create a list of time stacks, one for each sector
  # This structure is used to plot each sector at each time
  # This is needed because the syntax ls[[1:10]][[iSector]] doesn't work.
  # s_ghgTotal could be named s_ghgByTime, but is also used to store the totalling over sectors at each time
  ls_ghgBySectorByTime <- replicate(nSectors, s_ghgTotal)

  for (iRow in 1:(dim(alpha_df)[1])){
    #iRow <- 4
    iTime   <- alpha_df$iTime[iRow]
    iSector <- as.numeric(alpha_df$sector[iRow])
    ls_ghgByTimeBySector[[iTime]][[iSector]] <- 
      ghgBySector[[alpha_df$sector[iRow]]] * alpha_df$alpha[iRow]

    # put the same values in the other data structure
    ls_ghgBySectorByTime[[iSector]][[iTime]] <- 
    ls_ghgByTimeBySector[[iTime]][[iSector]]
    # print some output
    #a <- cellStats(ghgBySector[[alpha_df$sector[iRow]]], "sum")
    #b <- cellStats(ls_ghgByTimeBySector[[alpha_df$iTime[iRow]]][[alpha_df$sector[iRow]]], "sum")
    #print(alpha_df[iRow,])
    #cat(a, b, "\n")
  }
  
  # call biogenic fluxes
  # flux_bio <- calc
  ####### this should surely be 11?? or n+1 #################
  ls_ghgBySectorByTime[[9]] <- flux_co2
  for (iTime in 1:(nTimes)){
    ls_ghgByTimeBySector[[iTime]] <- 
    addLayer(ls_ghgByTimeBySector[[iTime]], flux_co2[[iTime]])
  }
  
  for (iTime in 1:(nTimes)){
    # return a RasterLayer
    s_ghgTotal[[iTime]] <- sum(ls_ghgByTimeBySector[[iTime]])
    # return the sum
    total[iTime] <- cellStats(s_ghgTotal[[iTime]], "sum")
    print( cellStats(s_ghgTotal[[iTime]], "sum") )
  }
  
  # apply unit conversions
  s_ghgTotal <- s_ghgTotal * unitConv$value
  ls_ghgByTimeBySector <- lapply(ls_ghgByTimeBySector, function(x){x * unitConv$value})
  ls_ghgBySectorByTime <- lapply(ls_ghgBySectorByTime, function(x){x * unitConv$value})

  # set "units" attribute to returned objects
  attr(total, "units") <- "Tg y-1"
  attr(s_ghgTotal, "units") <- unitConv$name
  attr(ls_ghgByTimeBySector, "units") <- unitConv$name
  attr(ls_ghgBySectorByTime, "units") <- unitConv$name
  
  return(list(total=total, # vector of total emissions
    s_ghgTotal=s_ghgTotal, # stack of total emissions
    ls_ghgByTimeBySector=ls_ghgByTimeBySector,  # list of sector stacks of emissions, one per time
    ls_ghgBySectorByTime=ls_ghgBySectorByTime)) # list of time stacks of emissions, one per sector
}

flux_anthro <- calcFlux_anthro("ch4",   datect, "OSGB", "mol", "nano")
#myFlux <- calcFlux("ch4",   datect, "OSGB", "g",   "nano")
#myFlux <- calcFlux("co2",   datect, "OSGB", "mol", "micro")
#myFlux <- calcFlux("n2o",   datect, "OSGB", "mol", "nano")

flux_anthro$total
#myFlux$ls_ghgBySectorByTime
#attr(myFlux$s_ghgTotal, "units")
## works. numbers seem quite big - just afew outliers?
## mean rates sensible - multiply
flux_anthro$total * TgCH4yUK_to_nmolm2s
#myFlux$total * TgCO2yUK_to_umolm2s
#myFlux$total * TgN2OyUK_to_nmolm2s

hist(flux_anthro$s_ghgTotal)
#plot(myFlux$s_ghgTotal)
plot(flux_anthro$s_ghgTotal, zlim=c(0.001,50), col = (terrain.colors(255)), main = paste("Total emission at ", datect))
i <- 2
plot(myFlux$ls_ghgBySectorByTime[[i]], zlim=c(0.001,50), col = (terrain.colors(255)), main = paste(sectorName[i], "emission in ", datect))
### works up to here
## do proj lon-lat
## write to netCDF
## add plots / animation
## crop to an extent
## make into a package
## create("ukghg")
@

\section{Biogenic fluxes}
<<make_ukghg_biogenic, eval=FALSE, results='asis', echo=FALSE, warning=FALSE, message=FALSE>>=
# read in ch4 emissions
ch4_mean <- raster("C:/0Peter/curr/GREENHOUSE/methaneScaling/NVC_VegetationData/Fch4_nmolm2s.grd")
ch4_mean <- extend(ch4_mean, ghgBySector)
projection(ch4_mean) <- projection(ghgBySector)
compareRaster(ch4_mean, ghgBySector)
plot(ch4_mean, zlim=c(0.001,50), col = (terrain.colors(255)))
cellStats(ghgBySector, sum)
cellStats(ch4_mean, mean) / TgCH4yUK_to_nmolm2s
unitConv <- unit_conversion("ch4", "mol", "nano")
ch4_mean_Tgkm2y <- ch4_mean / unitConv$value
cellStats(ch4_mean_Tgkm2y, sum)
rf <- writeRaster(ch4_mean_Tgkm2y, filename="Fch4_mean_Tgkm2y.grd")
rn <- raster("Fch4_mean_Tgkm2y.grd")

# use majic GPP as proxy for LAI
gpp <- brick("C:/0Peter/curr/GREENHOUSE/Data/chess/plevy-test1-(Copy)_gpp_gb_monthly_2010.nc", varname = "gpp_gb", ncdf=TRUE)
gpp <- gpp[[31]] *1000/44*1e6 # kg to umol m-2 s-1
plot(gpp)
lai <- gpp * 2
plot(lai)
lai <- extend(lai, ghgBySector)
projection(lai) <- projection(ghgBySector)
compareRaster(lai, ghgBySector)
rf <- writeRaster(lai, filename="lai.grd")
rn <- raster("lai.grd")

startDate <- as.POSIXct(strptime("01/01/2006", "%d/%m/%Y"), tz = "UTC")
endDate   <- as.POSIXct(strptime("01/12/2006", "%d/%m/%Y"), tz = "UTC")
startDate <- as.POSIXct(strptime("01/06/2006", "%d/%m/%Y"), tz = "UTC")
endDate   <- as.POSIXct(strptime("01/06/2006 22:00", "%d/%m/%Y %H:%M"), tz = "UTC")
# create a sequence of dates
nTimes <- 12
datect <- seq(startDate, endDate, length = nTimes)
flux_co2 <- calcFlux_bio("co2", datect)
plot(flux_co2)
plot(sum(flux_co2))
cellStats(sum(flux_co2), mean)
cellStats(flux_co2, mean)
plot(cellStats(flux_co2, sum))
plot(cellStats(flux_co2, sum) * TgCO2yUK_to_umolm2s)
unitConv <- unit_conversion("co2", "mol", "micro")
plot(cellStats(flux_co2, mean))
plot(cellStats(flux_co2, mean) * unitConv$value)
@

\section{Other stuff}
<<plot_sensitivity, eval=FALSE, results='hide', echo=FALSE, warning=FALSE, message=FALSE>>=
stdf <- aggregate(alpha_year_df$alpha, by = list(alpha_year_df$sector), max)
stdf$s <- (stdf$x-1) * as.numeric(df[21,2:11])
stdf$timeScale <- "year"

sydf <- aggregate(alpha_yday_df$alpha, by = list(alpha_yday_df$sector), max)
sydf$s <- (sydf$x-1) * as.numeric(df[21,2:11])
sydf$timeScale <- "yday"

shdf <- aggregate(alpha_hour_df$alpha, by = list(alpha_hour_df$sector), max)
shdf$s <- (shdf$x-1) * as.numeric(df[21,2:11])
shdf$timeScale <- "hour"

swdf <- aggregate(alpha_wday_df$alpha, by = list(alpha_wday_df$sector), max)
swdf$s <- (swdf$x-1) * as.numeric(df[21,2:11])
swdf$timeScale <- "wday"

sdf <- rbind(stdf, sydf, swdf, shdf)
colnames(sdf) <- c("sector", "alpha", "s", "timeScale")
sdf$sectorName <- sectorName[sdf$sector]
dim(sdf)

## we can add levels this way:
str(sdf)
levels(sdf$sector) <- c(sdf$sector, "11")

sdf[41:44,] <-  c("11", "11", "11", "11", 
                  1, 1,    1, 1, 
#co2                  0.13, 1.5, 0, 4,
                  0.3, 1.5, 0, 0.8,
                  "year", "yday", "wday", "hour", 
                  "biogenic", "biogenic", "biogenic", "biogenic")

sdf$s <- as.numeric(sdf$s)

p <- ggplot(sdf, aes(x = sectorName, y = s, fill = factor(timeScale)))
#p <- p + geom_bar(stat = "identity", position="dodge")
p <- p + geom_bar(stat = "identity")
p <- p + ylab(expression(paste("Amplitude, ", italic(A[it]), ~mu*mol~m^-2~s^-1)))
p

pie(as.numeric(df[11,2:11]), labels = sectorName)
@

<<read_netCDF, eval=FALSE>>=
# file names for the netCDF files
fname <- paste("co2/uk_co2_", sectorName, "_GBOS_1km.nc", sep="")

# check netcdf files
for (iSector in 1:(nSectors)){
  print(nc_open(filename=fname))
}

# read in the netCDF files into a list of RasterBricks
s <- lapply(fname, brick, ncdf=TRUE)
s[[10]][[10]]
projection(s[[1]])
res(s[[1]])
@


<<flux_predictions_anim, eval=FALSE, results='hide', echo=FALSE, warning=FALSE, message=FALSE>>=
thresh <- 3
saveGIF(
for(iTime in 1:nTimes)
{
  #here you could also extract a RasterLayer from a RasterStack
  #plot((ghg[[i]]), zlim=c(0.001,thresh), col = (terrain.colors(255)), main = expression(paste(CH[4]~emission*" in 2011, Mg "*CH[4]~km^-2)), sub = expression(paste(Red~circles:~point~sources*" > "*100~Mg~CH[4]~y^-1~contributing~1*"%"*~of~total~emission)))
  plot(lsrt[[7]][[iTime]], zlim=c(0.001,thresh), col = (terrain.colors(255)), main = paste(sectorName[7], "Methane emission in ", datect[iTime]))
},
loop=0,
interval= 1,
outdir = getwd(),
 clean = FALSE,
moviename="ghg_movie")

ani.options(outdir = getwd(), loop=TRUE)
saveLatex({
## put any code here to produce several plots
par(mfrow=c(1,2))
for(iTime in 1:nTimes)
{
  #here you could also extract a RasterLayer from a RasterStack
  #plot((ghg[[i]]), zlim=c(0.001,thresh), col = (terrain.colors(255)), main = expression(paste(CH[4]~emission*" in 2011, Mg "*CH[4]~km^-2)), sub = expression(paste(Red~circles:~point~sources*" > "*100~Mg~CH[4]~y^-1~contributing~1*"%"*~of~total~emission)))
  plot(lsrt[[7]][[iTime]], zlim=c(0.001,3), col = (terrain.colors(255)), main = paste(sectorName[7], "emission in ", datect[iTime]))
  plot(lsrt[[10]][[iTime]], zlim=c(0.001,15), col = (terrain.colors(255)), main = paste(sectorName[10], "emission in ", datect[iTime]))
}
}, ani.dev = 'pdf', ani.type = 'pdf',
ani.height = 4, ani.width = 7, ani.opts='loop=TRUE, controls, width=.8\\linewidth')

#thresh <- 15
#animate(lsrt[[1]])
#plot(lsrt[[10]][[1]], zlim=c(0.001,thresh), col = (terrain.colors(255)), main = paste(sectorName[7], "Methane emission in ", datect[iTime]))
#animate(lsrt[[7]], zlim=c(0.001,thresh), col = (terrain.colors(255)), main = paste(sectorName[7], "Methane emission in ", datect[iTime]))
#save.image("ukghg.RData")
@

<<add_ethane, eval=TRUE, results='asis', echo=TRUE, warning=FALSE, message=FALSE>>=
# add ethane, C2H6
library(ukghg)
# rename sensibly
df_alpha_byYear_byGHG <- alpha_year_byGHG_df 
summary(df_alpha_byYear_byGHG)
head(df_alpha_byYear_byGHG)

# read the ethane time series data
df_c2h6 <- read.csv("P:/NEC06763_NERC-RP_Highlight_DARE/Data/ethane_extraction/grd_reference_stacks/alpha_df_ethane.csv")
head(df_c2h6)
summary(df_c2h6)
names(df_c2h6) <- c("year", "sector", "sectorName", "alpha_year", "gas")
df_c2h6$ghgName.ighg. <- "c2h6"; df_c2h6$gas <- NULL 
df_c2h6$id <- df_c2h6$sector
df_c2h6$alpha_year[is.na(df_c2h6$alpha_year)] <- 0
df_c2h6 <- subset(df_c2h6, sector <= 10 & year >= 1990)

df_alpha_byYear_byGHG <- rbind(df_alpha_byYear_byGHG, df_c2h6)

# read the NMVOC time series data
df_voc <- read.csv("P:/NEC06763_NERC-RP_Highlight_DARE/Data/ethane_extraction/grd_reference_stacks/alpha_df_nmvoc.csv")
head(df_voc)
summary(df_voc)
names(df_voc) <- c("year", "sector", "sectorName", "alpha_year", "gas")
df_voc$ghgName.ighg. <- "voc"; df_voc$gas <- NULL 
df_voc$id <- df_voc$sector
df_voc$alpha_year[is.na(df_voc$alpha_year)] <- 0
df_voc <- subset(df_voc, sector <= 10 & year >= 1990)

df_alpha_byYear_byGHG <- rbind(df_alpha_byYear_byGHG, df_voc)
alpha_year_byGHG_df <- df_alpha_byYear_byGHG
usethis::use_data(alpha_year_byGHG_df, overwrite = TRUE)

# read the spatial data
s_c2h6 <- stack("P:/NEC06763_NERC-RP_Highlight_DARE/Data/ethane_extraction/grd_reference_stacks/ethane_reference_2017_1x1_Tg.grd")
# reorder to SNAP sector order, excluding nature (11)
s_c2h6 <- s_c2h6[[sectorName]]

s_ch4 <- stack("C:/Users/plevy/Documents/ukghg/inst/extdata/ch4BySector_OSGB_1km.grd")
compareRaster(s_ch4, s_c2h6)

# check totals for reference year match
#print(sum(cellStats(s_c2h6, "sum")))

# assign attributes and write to native raster file
# ethane
attr(s_c2h6, "units") <- "Tg km-2 y-1"
rf <- writeRaster(s_c2h6, filename=paste("c2h6BySector.grd", sep=""), overwrite=TRUE)

path = "../ukghg/inst/extdata/"
ghgName <- "c2h6"
proj <- "OSGB"
res <- 1 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
rf <- writeRaster(s_c2h6, filename=fname)
cellStats(s_c2h6, sum)

res <- 20 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
s_agg <- aggregate(s_c2h6, fac = res)
rf <- writeRaster(s_agg, filename=fname)
cellStats(s_agg, sum) * res^2

res <- 100 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
s_agg <- aggregate(s_c2h6, fac = res)
rf <- writeRaster(s_agg, filename=fname)

# NMVOCs
# read the spatial data
s_voc <- stack("P:/NEC06763_NERC-RP_Highlight_DARE/Data/ethane_extraction/grd_reference_stacks/nmvoc_reference_2017_1x1_Tg.grd")
# reorder to SNAP sector order, excluding nature (11)
s_voc <- s_voc[[sectorName]]

s_ch4 <- stack("C:/Users/plevy/Documents/ukghg/inst/extdata/ch4BySector_OSGB_1km.grd")
compareRaster(s_ch4, s_voc)
attr(s_voc, "units") <- "Tg km-2 y-1"

path = "../ukghg/inst/extdata/"
ghgName <- "voc"
proj <- "OSGB"
res <- 1 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
rf <- writeRaster(s_voc, filename=fname)
cellStats(s_voc, sum)

res <- 20 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
s_agg <- aggregate(s_voc, fac = res)
rf <- writeRaster(s_agg, filename=fname, overwrite=TRUE)
cellStats(s_agg, sum) * res^2

res <- 100 # km
fname <- paste(ghgName, "BySector_", proj, "_", res, "km.grd", sep="")
s_agg <- aggregate(s_voc, fac = res)
rf <- writeRaster(s_agg, filename=fname)
@

\section{Summary} 
\begin{outline}
\1 We have a method/model for estimating UK anthropogenic GHG emissions by sector and time.
\1 We can use the parameters of this to estimate the information content in atmospheric concentration data
\1 Something similar could be applied to biogenic fluxes ...
\1 Biogenic emissions of CO$_2$ dominate at short time scales
\2 useful information or effectively noise?
\1 Agricultural emissions of CH$_4$ and N$_2$O provide a strong signal
\2 good potential for inverse modelling
\end{outline} 

\end{document}